# The lexo Implementation Playbook - Feature Prompts
## Production-Ready Prompts for Core Business Features

---

## Phase 2: Core Data Layer & Supabase Integration

### Prompt 2.1: Database Schema & Migration
```typescript
// AI_TASK: Create complete Supabase schema for lexo with RLS policies and migrations
// CONTEXT: South African advocate practice management with multi-Bar support
// REQUIREMENTS: ACID compliance, row-level security, audit trails, soft deletes

// --- SUPABASE SCHEMA CREATION ---
// AI_TARGET_FILE: supabase/migrations/001_initial_schema.sql
// AI_EXPECTATIONS: Create all tables with proper constraints, indexes, and RLS policies

/*
-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Custom types
CREATE TYPE bar_association AS ENUM ('johannesburg', 'cape_town');
CREATE TYPE matter_status AS ENUM ('active', 'pending', 'settled', 'closed', 'on_hold');
CREATE TYPE invoice_status AS ENUM ('draft', 'sent', 'viewed', 'paid', 'overdue', 'disputed', 'written_off');
CREATE TYPE payment_method AS ENUM ('eft', 'cheque', 'cash', 'card', 'debit_order');
CREATE TYPE risk_level AS ENUM ('low', 'medium', 'high', 'critical');
CREATE TYPE time_entry_method AS ENUM ('manual', 'voice', 'timer', 'ai_suggested');
CREATE TYPE document_type AS ENUM ('brief', 'opinion', 'contract', 'correspondence', 'court_document', 'invoice', 'receipt', 'other');
CREATE TYPE fee_type AS ENUM ('standard', 'contingency', 'success', 'retainer', 'pro_bono');

-- Users table (advocates)
CREATE TABLE advocates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  email VARCHAR(255) UNIQUE NOT NULL,
  full_name VARCHAR(255) NOT NULL,
  initials VARCHAR(10) NOT NULL,
  practice_number VARCHAR(50) UNIQUE NOT NULL,
  bar bar_association NOT NULL,
  year_admitted INTEGER NOT NULL CHECK (year_admitted >= 1900 AND year_admitted <= EXTRACT(YEAR FROM CURRENT_DATE)),
  specialisations TEXT[] DEFAULT '{}',
  hourly_rate DECIMAL(10,2) NOT NULL CHECK (hourly_rate > 0),
  contingency_rate DECIMAL(3,2) CHECK (contingency_rate >= 0 AND contingency_rate <= 1),
  success_fee_rate DECIMAL(3,2) CHECK (success_fee_rate >= 0 AND success_fee_rate <= 1),
  
  -- Contact details
  phone_number VARCHAR(20),
  chambers_address TEXT,
  postal_address TEXT,
  
  -- Settings
  notification_preferences JSONB DEFAULT '{"email": true, "whatsapp": false, "sms": false}',
  invoice_settings JSONB DEFAULT '{"auto_remind": true, "reminder_days": [30, 45, 55]}',
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  last_login_at TIMESTAMPTZ,
  is_active BOOLEAN DEFAULT true,
  deleted_at TIMESTAMPTZ,
  
  -- Computed fields for quick access
  total_outstanding DECIMAL(12,2) DEFAULT 0,
  total_collected_ytd DECIMAL(12,2) DEFAULT 0,
  matters_count INTEGER DEFAULT 0
);

-- Matters table with comprehensive tracking
CREATE TABLE matters (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  advocate_id UUID NOT NULL REFERENCES advocates(id) ON DELETE CASCADE,
  
  -- Basic Information
  reference_number VARCHAR(50) UNIQUE NOT NULL,
  title VARCHAR(500) NOT NULL,
  description TEXT,
  matter_type VARCHAR(100) NOT NULL,
  court_case_number VARCHAR(100),
  bar bar_association NOT NULL,
  
  -- Client Information
  client_name VARCHAR(255) NOT NULL,
  client_email VARCHAR(255),
  client_phone VARCHAR(20),
  client_address TEXT,
  client_type VARCHAR(50) CHECK (client_type IN ('individual', 'company', 'trust', 'government', 'ngo')),
  
  -- Instructing Attorney Information
  instructing_attorney VARCHAR(255) NOT NULL,
  instructing_attorney_email VARCHAR(255),
  instructing_attorney_phone VARCHAR(20),
  instructing_firm VARCHAR(255),
  instructing_firm_ref VARCHAR(100),
  
  -- Financial Information
  fee_type fee_type DEFAULT 'standard',
  estimated_fee DECIMAL(12,2),
  fee_cap DECIMAL(12,2),
  actual_fee DECIMAL(12,2),
  wip_value DECIMAL(12,2) DEFAULT 0,
  trust_balance DECIMAL(12,2) DEFAULT 0,
  disbursements DECIMAL(12,2) DEFAULT 0,
  vat_exempt BOOLEAN DEFAULT false,
  
  -- Status and Risk
  status matter_status DEFAULT 'pending',
  risk_level risk_level DEFAULT 'low',
  settlement_probability DECIMAL(3,2) CHECK (settlement_probability >= 0 AND settlement_probability <= 1),
  expected_completion_date DATE,
  
  -- Conflict Check
  conflict_check_completed BOOLEAN DEFAULT false,
  conflict_check_date TIMESTAMPTZ,
  conflict_check_cleared BOOLEAN,
  conflict_notes TEXT,
  
  -- Important Dates
  date_instructed DATE NOT NULL DEFAULT CURRENT_DATE,
  date_accepted DATE,
  date_commenced DATE,
  date_settled DATE,
  date_closed DATE,
  next_court_date DATE,
  prescription_date DATE,
  
  -- Metadata
  tags TEXT[] DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  deleted_at TIMESTAMPTZ,
  
  -- Computed fields
  days_active INTEGER GENERATED ALWAYS AS (
    CASE 
      WHEN date_closed IS NOT NULL THEN EXTRACT(DAY FROM (date_closed - date_instructed))
      ELSE EXTRACT(DAY FROM (NOW() - date_instructed))
    END
  ) STORED,
  
  is_overdue BOOLEAN GENERATED ALWAYS AS (
    CASE 
      WHEN expected_completion_date IS NOT NULL AND status IN ('active', 'pending') 
      THEN expected_completion_date < CURRENT_DATE
      ELSE false
    END
  ) STORED
);

-- Invoices table with Bar-specific rules
CREATE TABLE invoices (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  matter_id UUID NOT NULL REFERENCES matters(id) ON DELETE CASCADE,
  advocate_id UUID NOT NULL REFERENCES advocates(id) ON DELETE CASCADE,
  
  -- Invoice Details
  invoice_number VARCHAR(50) UNIQUE NOT NULL,
  invoice_date DATE NOT NULL DEFAULT CURRENT_DATE,
  due_date DATE NOT NULL,
  bar bar_association NOT NULL,
  
  -- Financial Details
  fees_amount DECIMAL(12,2) NOT NULL CHECK (fees_amount >= 0),
  disbursements_amount DECIMAL(12,2) DEFAULT 0 CHECK (disbursements_amount >= 0),
  subtotal DECIMAL(12,2) GENERATED ALWAYS AS (fees_amount + disbursements_amount) STORED,
  vat_rate DECIMAL(3,2) DEFAULT 0.15,
  vat_amount DECIMAL(12,2) GENERATED ALWAYS AS ((fees_amount + disbursements_amount) * vat_rate) STORED,
  total_amount DECIMAL(12,2) GENERATED ALWAYS AS ((fees_amount + disbursements_amount) * (1 + vat_rate)) STORED,
  
  -- Payment Tracking
  status invoice_status DEFAULT 'draft',
  amount_paid DECIMAL(12,2) DEFAULT 0 CHECK (amount_paid >= 0),
  balance_due DECIMAL(12,2) GENERATED ALWAYS AS (
    ((fees_amount + disbursements_amount) * (1 + vat_rate)) - amount_paid
  ) STORED,
  date_paid DATE,
  payment_method payment_method,
  payment_reference VARCHAR(100),
  
  -- Fee Narrative
  fee_narrative TEXT NOT NULL,
  internal_notes TEXT,
  
  -- Reminder Tracking
  reminders_sent INTEGER DEFAULT 0,
  last_reminder_date DATE,
  next_reminder_date DATE,
  reminder_history JSONB DEFAULT '[]',
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  sent_at TIMESTAMPTZ,
  viewed_at TIMESTAMPTZ,
  deleted_at TIMESTAMPTZ,
  
  -- Computed fields
  days_outstanding INTEGER GENERATED ALWAYS AS (
    CASE 
      WHEN date_paid IS NOT NULL THEN EXTRACT(DAY FROM (date_paid - invoice_date))
      WHEN status IN ('sent', 'viewed', 'overdue') THEN EXTRACT(DAY FROM (NOW() - invoice_date))
      ELSE NULL
    END
  ) STORED,
  
  is_overdue BOOLEAN GENERATED ALWAYS AS (
    CASE 
      WHEN status NOT IN ('paid', 'written_off') AND due_date < CURRENT_DATE 
      THEN true 
      ELSE false 
    END
  ) STORED
);

-- Time entries with voice transcription support
CREATE TABLE time_entries (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  matter_id UUID NOT NULL REFERENCES matters(id) ON DELETE CASCADE,
  advocate_id UUID NOT NULL REFERENCES advocates(id) ON DELETE CASCADE,
  invoice_id UUID REFERENCES invoices(id) ON DELETE SET NULL,
  
  -- Time Details
  date DATE NOT NULL DEFAULT CURRENT_DATE,
  start_time TIME,
  end_time TIME,
  duration_minutes INTEGER NOT NULL CHECK (duration_minutes > 0),
  
  -- Billing Details
  description TEXT NOT NULL,
  billable BOOLEAN DEFAULT true,
  rate DECIMAL(10,2) NOT NULL,
  amount DECIMAL(12,2) GENERATED ALWAYS AS ((duration_minutes / 60.0) * rate) STORED,
  
  -- Recording Method
  recording_method time_entry_method DEFAULT 'manual',
  voice_transcription TEXT,
  voice_recording_url TEXT,
  
  -- Status
  billed BOOLEAN DEFAULT false,
  write_off BOOLEAN DEFAULT false,
  write_off_reason TEXT,
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  deleted_at TIMESTAMPTZ
);

-- Documents table
CREATE TABLE documents (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  matter_id UUID NOT NULL REFERENCES matters(id) ON DELETE CASCADE,
  advocate_id UUID NOT NULL REFERENCES advocates(id) ON DELETE CASCADE,
  
  -- Document Details
  filename VARCHAR(255) NOT NULL,
  original_filename VARCHAR(255) NOT NULL,
  document_type document_type NOT NULL,
  mime_type VARCHAR(100) NOT NULL,
  size_bytes BIGINT NOT NULL,
  storage_path TEXT NOT NULL,
  
  -- Version Control
  version INTEGER DEFAULT 1,
  parent_document_id UUID REFERENCES documents(id) ON DELETE SET NULL,
  
  -- Metadata
  description TEXT,
  tags TEXT[] DEFAULT '{}',
  uploaded_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  deleted_at TIMESTAMPTZ,
  
  -- Full-text search
  content_text TEXT,
  content_vector tsvector GENERATED ALWAYS AS (to_tsvector('english', coalesce(content_text, ''))) STORED
);

-- Notes/Comments table
CREATE TABLE notes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  matter_id UUID NOT NULL REFERENCES matters(id) ON DELETE CASCADE,
  advocate_id UUID NOT NULL REFERENCES advocates(id) ON DELETE CASCADE,
  
  content TEXT NOT NULL,
  is_internal BOOLEAN DEFAULT true,
  is_important BOOLEAN DEFAULT false,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  deleted_at TIMESTAMPTZ
);

-- Referrals tracking table
CREATE TABLE referrals (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  matter_id UUID NOT NULL REFERENCES matters(id) ON DELETE CASCADE,
  
  -- Referral parties
  referring_advocate_id UUID REFERENCES advocates(id) ON DELETE SET NULL,
  referred_to_advocate_id UUID REFERENCES advocates(id) ON DELETE SET NULL,
  referring_firm VARCHAR(255),
  
  -- Referral details
  referral_date DATE NOT NULL DEFAULT CURRENT_DATE,
  referral_fee_percentage DECIMAL(3,2) CHECK (referral_fee_percentage >= 0 AND referral_fee_percentage <= 1),
  referral_fee_amount DECIMAL(12,2),
  referral_fee_paid BOOLEAN DEFAULT false,
  referral_fee_paid_date DATE,
  
  -- Reciprocal tracking
  reciprocal_expected BOOLEAN DEFAULT false,
  reciprocal_completed BOOLEAN DEFAULT false,
  
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Payments table for tracking all financial transactions
CREATE TABLE payments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  invoice_id UUID REFERENCES invoices(id) ON DELETE CASCADE,
  advocate_id UUID NOT NULL REFERENCES advocates(id) ON DELETE CASCADE,
  
  -- Payment details
  amount DECIMAL(12,2) NOT NULL CHECK (amount > 0),
  payment_date DATE NOT NULL DEFAULT CURRENT_DATE,
  payment_method payment_method NOT NULL,
  reference VARCHAR(100),
  
  -- Bank reconciliation
  bank_reference VARCHAR(100),
  reconciled BOOLEAN DEFAULT false,
  reconciled_date DATE,
  
  -- Trust accounting
  is_trust_deposit BOOLEAN DEFAULT false,
  trust_transfer_date DATE,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Audit log table
CREATE TABLE audit_log (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  advocate_id UUID REFERENCES advocates(id) ON DELETE SET NULL,
  
  table_name VARCHAR(50) NOT NULL,
  record_id UUID NOT NULL,
  action VARCHAR(20) NOT NULL CHECK (action IN ('INSERT', 'UPDATE', 'DELETE', 'VIEW')),
  
  old_values JSONB,
  new_values JSONB,
  
  ip_address INET,
  user_agent TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for performance
CREATE INDEX idx_matters_advocate ON matters(advocate_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_matters_status ON matters(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_matters_dates ON matters(date_instructed, date_closed) WHERE deleted_at IS NULL;
CREATE INDEX idx_invoices_matter ON invoices(matter_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_invoices_status ON invoices(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_invoices_due_date ON invoices(due_date) WHERE deleted_at IS NULL AND status NOT IN ('paid', 'written_off');
CREATE INDEX idx_time_entries_matter ON time_entries(matter_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_time_entries_unbilled ON time_entries(matter_id) WHERE billed = false AND deleted_at IS NULL;
CREATE INDEX idx_documents_matter ON documents(matter_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_documents_search ON documents USING GIN(content_vector);
CREATE INDEX idx_payments_invoice ON payments(invoice_id);
CREATE INDEX idx_audit_log_advocate ON audit_log(advocate_id, created_at DESC);

-- Create views for common queries
CREATE VIEW active_matters AS
SELECT * FROM matters 
WHERE status IN ('active', 'pending') 
AND deleted_at IS NULL;

CREATE VIEW overdue_invoices AS
SELECT * FROM invoices 
WHERE is_overdue = true 
AND status NOT IN ('paid', 'written_off')
AND deleted_at IS NULL;

CREATE VIEW unbilled_time AS
SELECT 
  te.*,
  m.title as matter_title,
  m.client_name
FROM time_entries te
JOIN matters m ON te.matter_id = m.id
WHERE te.billed = false 
AND te.deleted_at IS NULL
AND m.deleted_at IS NULL;

-- Row Level Security Policies
ALTER TABLE advocates ENABLE ROW LEVEL SECURITY;
ALTER TABLE matters ENABLE ROW LEVEL SECURITY;
ALTER TABLE invoices ENABLE ROW LEVEL SECURITY;
ALTER TABLE time_entries ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;
ALTER TABLE notes ENABLE ROW LEVEL SECURITY;
ALTER TABLE payments ENABLE ROW LEVEL SECURITY;

-- RLS Policies (advocates can only see their own data)
CREATE POLICY advocate_policy ON advocates
  FOR ALL USING (auth.uid()::text = id::text);

CREATE POLICY matters_policy ON matters
  FOR ALL USING (auth.uid()::text = advocate_id::text);

CREATE POLICY invoices_policy ON invoices
  FOR ALL USING (auth.uid()::text = advocate_id::text);

CREATE POLICY time_entries_policy ON time_entries
  FOR ALL USING (auth.uid()::text = advocate_id::text);

CREATE POLICY documents_policy ON documents
  FOR ALL USING (auth.uid()::text = advocate_id::text);

CREATE POLICY notes_policy ON notes
  FOR ALL USING (auth.uid()::text = advocate_id::text);

CREATE POLICY payments_policy ON payments
  FOR ALL USING (auth.uid()::text = advocate_id::text);

-- Functions for business logic
CREATE OR REPLACE FUNCTION calculate_due_date(invoice_date DATE, bar bar_association)
RETURNS DATE AS $$
BEGIN
  CASE bar
    WHEN 'johannesburg' THEN
      RETURN invoice_date + INTERVAL '60 days';
    WHEN 'cape_town' THEN
      RETURN invoice_date + INTERVAL '90 days';
    ELSE
      RETURN invoice_date + INTERVAL '60 days';
  END CASE;
END;
$$ LANGUAGE plpgsql;

-- Trigger to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply update trigger to all relevant tables
CREATE TRIGGER update_advocates_updated_at BEFORE UPDATE ON advocates
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
  
CREATE TRIGGER update_matters_updated_at BEFORE UPDATE ON matters
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
  
CREATE TRIGGER update_invoices_updated_at BEFORE UPDATE ON invoices
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- Function to check for conflicts
CREATE OR REPLACE FUNCTION check_conflict(
  p_advocate_id UUID,
  p_client_name VARCHAR,
  p_opposing_party VARCHAR
)
RETURNS TABLE(
  has_conflict BOOLEAN,
  conflicting_matters UUID[],
  conflict_reason TEXT
) AS $$
DECLARE
  v_conflicts UUID[];
BEGIN
  -- Check if advocate has represented opposing party before
  SELECT ARRAY_AGG(id) INTO v_conflicts
  FROM matters
  WHERE advocate_id = p_advocate_id
  AND deleted_at IS NULL
  AND (
    LOWER(client_name) = LOWER(p_opposing_party)
    OR LOWER(client_name) LIKE '%' || LOWER(p_opposing_party) || '%'
  );
  
  IF v_conflicts IS NOT NULL THEN
    RETURN QUERY 
    SELECT 
      true,
      v_conflicts,
      'Previously represented the opposing party';
    RETURN;
  END IF;
  
  -- Check if advocate has matters against this client
  SELECT ARRAY_AGG(id) INTO v_conflicts
  FROM matters
  WHERE advocate_id = p_advocate_id
  AND deleted_at IS NULL
  AND description ILIKE '%' || p_client_name || '%';
  
  IF v_conflicts IS NOT NULL THEN
    RETURN QUERY 
    SELECT 
      true,
      v_conflicts,
      'Potential conflict with existing matter';
    RETURN;
  END IF;
  
  -- No conflicts found
  RETURN QUERY 
  SELECT 
    false,
    NULL::UUID[],
    'No conflicts detected';
END;
$$ LANGUAGE plpgsql;
*/
```

### Prompt 2.2: Supabase Service Layer
```typescript
// AI_TASK: Create comprehensive Supabase service layer with type-safe operations
// REQUIREMENTS: Error handling, retry logic, optimistic updates, offline support

// --- SUPABASE CLIENT & CONFIGURATION ---
// AI_TARGET_FILE: src/lib/supabase.ts
// AI_EXPECTATIONS: Configure Supabase client with proper typing and error handling

/*
import { createClient } from '@supabase/supabase-js';
import type { Database } from './database.types';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables');
}

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
  },
  global: {
    headers: { 'x-application-name': 'lexo' },
  },
});

// Generate TypeScript types from database
export type Tables<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Row'];
  
export type Inserts<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Insert'];
  
export type Updates<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Update'];
*/

// --- API SERVICE LAYER ---
// AI_TARGET_FILE: src/services/api/matters.service.ts
// AI_EXPECTATIONS: Create comprehensive matter management service with business logic

/*
import { supabase } from '@/lib/supabase';
import type { Matter, NewMatterForm, MatterStatus } from '@/types';
import { z } from 'zod';
import { toast } from 'react-hot-toast';

// Validation schemas
const MatterValidation = z.object({
  title: z.string().min(3).max(500),
  clientName: z.string().min(2).max(255),
  clientEmail: z.string().email().optional().or(z.literal('')),
  clientPhone: z.string().regex(/^[0-9+\-\s()]+$/).optional().or(z.literal('')),
  instructingAttorney: z.string().min(2).max(255),
  instructingAttorneyEmail: z.string().email().optional().or(z.literal('')),
  bar: z.enum(['johannesburg', 'cape_town']),
  briefType: z.string().min(2).max(100),
  estimatedFee: z.number().positive().optional(),
  riskLevel: z.enum(['low', 'medium', 'high'])
});

export class MatterService {
  // Create a new matter with conflict checking
  static async createMatter(data: NewMatterForm): Promise<Matter> {
    try {
      // Validate input
      const validated = MatterValidation.parse(data);
      
      // Get current user
      const { data: { user }, error: userError } = await supabase.auth.getUser();
      if (userError || !user) throw new Error('User not authenticated');
      
      // Perform conflict check
      const { data: conflictCheck, error: conflictError } = await supabase
        .rpc('check_conflict', {
          p_advocate_id: user.id,
          p_client_name: validated.clientName,
          p_opposing_party: '' // Would be extracted from description in full implementation
        });
        
      if (conflictError) throw conflictError;
      
      if (conflictCheck?.has_conflict) {
        const proceed = await this.confirmConflictOverride(conflictCheck.conflict_reason);
        if (!proceed) throw new Error('Matter creation cancelled due to conflict');
      }
      
      // Generate reference number
      const referenceNumber = await this.generateReferenceNumber(validated.bar);
      
      // Create the matter
      const { data: matter, error } = await supabase
        .from('matters')
        .insert({
          advocate_id: user.id,
          reference_number: referenceNumber,
          title: validated.title,
          client_name: validated.clientName,
          client_email: validated.clientEmail || null,
          client_phone: validated.clientPhone || null,
          instructing_attorney: validated.instructingAttorney,
          instructing_attorney_email: validated.instructingAttorneyEmail || null,
          instructing_firm: validated.instructingFirm || null,
          bar: validated.bar,
          matter_type: validated.briefType,
          estimated_fee: validated.estimatedFee || null,
          risk_level: validated.riskLevel,
          status: 'pending',
          conflict_check_completed: !conflictCheck?.has_conflict,
          conflict_check_date: new Date().toISOString(),
        })
        .select()
        .single();
        
      if (error) throw error;
      
      // Log the action
      await this.auditLog('matters', matter.id, 'INSERT', null, matter);
      
      toast.success('Matter created successfully');
      return matter;
      
    } catch (error) {
      console.error('Error creating matter:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to create matter');
      throw error;
    }
  }
  
  // Update matter status with validation
  static async updateMatterStatus(
    matterId: string, 
    newStatus: MatterStatus, 
    reason?: string
  ): Promise<Matter> {
    try {
      const { data: currentMatter } = await supabase
        .from('matters')
        .select('*')
        .eq('id', matterId)
        .single();
        
      if (!currentMatter) throw new Error('Matter not found');
      
      // Validate status transition
      if (!this.isValidStatusTransition(currentMatter.status, newStatus)) {
        throw new Error(`Invalid status transition from ${currentMatter.status} to ${newStatus}`);
      }
      
      // Prepare update data
      const updateData: any = {
        status: newStatus,
        updated_at: new Date().toISOString()
      };
      
      // Add status-specific fields
      if (newStatus === 'closed') {
        updateData.date_closed = new Date().toISOString();
      } else if (newStatus === 'settled') {
        updateData.date_settled = new Date().toISOString();
      } else if (newStatus === 'active') {
        updateData.date_commenced = new Date().toISOString();
      }
      
      const { data: updatedMatter, error } = await supabase
        .from('matters')
        .update(updateData)
        .eq('id', matterId)
        .select()
        .single();
        
      if (error) throw error;
      
      // Add note if reason provided
      if (reason) {
        await supabase.from('notes').insert({
          matter_id: matterId,
          advocate_id: currentMatter.advocate_id,
          content: `Status changed from ${currentMatter.status} to ${newStatus}: ${reason}`,
          is_internal: true
        });
      }
      
      // Audit log
      await this.auditLog('matters', matterId, 'UPDATE', currentMatter, updatedMatter);
      
      toast.success(`Matter status updated to ${newStatus}`);
      return updatedMatter;
      
    } catch (error) {
      console.error('Error updating matter status:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to update matter status');
      throw error;
    }
  }
  
  // Get matters with filtering, sorting, and pagination
  static async getMatters(options: {
    page?: number;
    pageSize?: number;
    status?: MatterStatus[];
    search?: string;
    sortBy?: string;
    sortOrder?: 'asc' | 'desc';
  } = {}) {
    const {
      page = 1,
      pageSize = 10,
      status,
      search,
      sortBy = 'created_at',
      sortOrder = 'desc'
    } = options;
    
    try {
      let query = supabase
        .from('matters')
        .select('*, time_entries(count)', { count: 'exact' })
        .is('deleted_at', null);
      
      // Apply filters
      if (status && status.length > 0) {
        query = query.in('status', status);
      }
      
      if (search) {
        query = query.or(`title.ilike.%${search}%,client_name.ilike.%${search}%,reference_number.ilike.%${search}%`);
      }
      
      // Apply sorting
      query = query.order(sortBy, { ascending: sortOrder === 'asc' });
      
      // Apply pagination
      const from = (page - 1) * pageSize;
      const to = from + pageSize - 1;
      query = query.range(from, to);
      
      const { data, error, count } = await query;
      
      if (error) throw error;
      
      return {
        data: data || [],
        pagination: {
          page,
          pageSize,
          total: count || 0,
          totalPages: Math.ceil((count || 0) / pageSize)
        }
      };
      
    } catch (error) {
      console.error('Error fetching matters:', error);
      toast.error('Failed to fetch matters');
      throw error;
    }
  }
  
  // Helper: Generate reference number
  private static async generateReferenceNumber(bar: string): Promise<string> {
    const year = new Date().getFullYear();
    const prefix = bar === 'johannesburg' ? 'JHB' : 'CPT';
    
    // Get the last reference number for this year and bar
    const { data } = await supabase
      .from('matters')
      .select('reference_number')
      .like('reference_number', `${prefix}/${year}/%`)
      .order('reference_number', { ascending: false })
      .limit(1);
    
    let nextNumber = 1;
    if (data && data.length > 0) {
      const lastRef = data[0].reference_number;
      const lastNumber = parseInt(lastRef.split('/').pop() || '0');
      nextNumber = lastNumber + 1;
    }
    
    return `${prefix}/${year}/${nextNumber.toString().padStart(4, '0')}`;
  }
  
  // Helper: Validate status transitions
  private static isValidStatusTransition(from: MatterStatus, to: MatterStatus): boolean {
    const validTransitions: Record<MatterStatus, MatterStatus[]> = {
      'pending': ['active', 'closed'],
      'active': ['settled', 'closed', 'on_hold'],
      'on_hold': ['active', 'closed'],
      'settled': ['closed'],
      'closed': [] // No transitions from closed
    };
    
    return validTransitions[from]?.includes(to) || false;
  }
  
  // Helper: Confirm conflict override
  private static async confirmConflictOverride(reason: string): Promise<boolean> {
    // In a real implementation, this would show a modal
    return confirm(`Conflict detected: ${reason}\n\nDo you want to proceed anyway?`);
  }
  
  // Helper: Audit logging
  private static async auditLog(
    table: string,
    recordId: string,
    action: string,
    oldValues: any,
    newValues: any
  ) {
    await supabase.from('audit_log').insert({
      table_name: table,
      record_id: recordId,
      action,
      old_values: oldValues,
      new_values: newValues
    });
  }
}
*/